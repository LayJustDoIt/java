Create key and certificate:
keytool -genkey -dname "cn=ProJavaServer, ou=Java, o=Wrox Press, c=US" -alias wrox -keypass secret -storepass secret -validity 365 -keystore .\keystore

Check the certifacate:
keytool -list -keystore .\keystore -storepass secret

Export it to a file and ginve the client to use it:
keytool -export -keystore .\keystore -storepass secret -file clientimport.cer -alias wrox

Server side policy file:
ssl.policy
grant {
	permission java.security.AllPermission;
}

Client VM to do:
1) Import the digital certificate to keystore base, and trust it;
2) Use same keystore base as server side.
keytool -import -file clientimport.cer -alias wrox -storepass secret

Run client:
java -Djava.security.policy=ssl.policy -Djavax.net.ssl.trustStore=.\keystore
ClientProgram

Server side code:
import java.io.*;
import java.net.*;
import java.security.*;
import javax.net.ssl.*;
import javax.security.cert.*;
import com.sun.net.ssl.*;
......
int port;
SSLServerSocketFactory ssf = null;
// Set up key manager to do server authentication
char[] passphrase = "secret".toCharArray();
try {
	// Get a context for the protocol. We can use SSL of TLS as needed.
	SSLContext ctx = SSLContext.getInstance("TLS");
	KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
	
	// Open the keystore with the password 
	// and initialize the SSL context with this keystore.
	KeyStore ks = KeyStore.getInstance("JKS");
	ks.load(new FileInputStream(".\\keystore"), passphrase);
	kmf.init(ks, passphrase);
	ctx.init(kmf.getKeyManagers(), null, null);
	ssf = ctx.getServerSocketFactory();
}catch(Exception ex){
	e.printStackTrace();
}
ssf.createServerSocket(port);